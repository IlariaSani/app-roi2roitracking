function [mergedFG, mergedClassification]=bsc_mergeFGandClass(inputFGs,inputClassifications)
%% [mergedFG, mergedClassification]=bsc_mergeFGandClass(inputFGs,inputClassifications)
%
% Takes in some number of fg structures (and classification structures) and
% merges them together into one omnibus fg structure (and classification
% structure) wherein the streamiline ordering (and this classification
% indexing) is preserved.
%
%% Inputs/Outputs
% Inputs:
% -inputFGs: either a series of paths to fg structures or an array of fg
% structures. Can be interspersed, and adapt to whatever input type (i.e.
% random assortment of strings, tck, objects etc).
% -inputClassifications: same as above, except for classification
% structures.  Might be slightly more brittle.
%
% Outputs:
% mergedFG: a fibergroup (fg) structure who streamines correspond to all input
% fibergroups (fg)s
% mergedClassification:  a classification structure which 
%
%%   IMPORTANT NOTES:
%
%  >THIS FUNCTION REQUIRES VISTASOFT
%
%  >You do not have to put in a classification structure.  In such cases it
%  will basically behave like fgMerge, except it keeps track of the source
%  fibergroups (fg)s in the cassification structure.  Without the
%  classification structure there is no "provenance" on where the source
%  fibergroups came from (which may be fine, given your goals).
%
%  >Input FG structures and classificaiton structures are presumed to be
%  paired.  In other words, in the event that ANYTHING is passed in through
%  the inputClassifications variable (see above), it is presumed that the
%  ii entry in inputFGs corresponds to the ii entry in inputClassifications
%
%
%% Example Uses:
%
%  1.  Merging a tracking parameter sweep:  If you have several different
%  fgs generated by different tractography parameter settings, this will
%  provide a merged fg structure along with a classification structure
%  telling you which streamlines came from which source tractography
%
%  2.  Merging multiple segmentations:  By inputting multiple source whole
%  brain fiber groups (from the same subject), along with the classification structure from each
%  corresponding segmentation, you can create a "merged replication
%  segmentation" which presumably has more streamlines representing each
%  particular tract. 
%
%  3.  Incorporating tracts generated from other methods into an exsting
%  whole brain fiber group and segmentation:  if one already has a whole
%  brain tractography (and corresponding tractography)  it is possible to
%  "append" more tracts to the source wbfg and classification structure.
%  The tracts to be appended do not need corresponding classification
%  structures and will be added to the existing classification structure
%  (the one that corresponds to the whole brain tractography, should it
%  exist).  Their names will be derived from the name in the fg.name field.
%
% (C) Daniel Bullock, 2018, Indiana University
%
%  Requires vistasoft
%% Begin function
% create a blank classification object if one isn't passed
%doesnt really matter what's in it right now
if ~exist('inputClassifications') ==1
    for iInputs=1:length(inputFGs)
    inputClassifications{iInputs}=[];
    end
end

%if the length of the input vectors are not equivalent, append empty
%entries to the classification input such that you don't get indexing
%errors later. 
if length(inputClassifications)<length(inputFGs)
    inputClassifications{length(inputClassifications)+1:length(inputFGs)}=[];
end
    

%iterates for the number of tracts input 
for iInputs=1:length(inputFGs)
    
    %loads the tract
    [toMergeFG, ~] = bsc_LoadAndParseFiberStructure(inputFGs{iInputs});
    
    %checks to see if the .fibers field is empty, or if the thing in the
    %.fibers field is of 0 length (apparently this happens when converting
    %from empty trk files.
    if ~or(length(toMergeFG.fibers)==0,length(toMergeFG.fibers{1})==0);
        %if the mergedFG structure doesn't exist yet, take the input fg structure
        %and set that as the mergedFG structure, along with a
        %blank merged classification structure
        if ~exist('mergedFG') ==1
            mergedFG=toMergeFG;
            mergedClassification.names=[];
            mergedClassification.index=[];
        else
            %if the mergedFG does exist, go ahead and append the current tract
            %with it.
            mergedFG.fibers=vertcat(mergedFG.fibers,toMergeFG.fibers);
            mergedFG.name=strcat(mergedFG.name,toMergeFG.name);
         

            toMergeClassification.names=[];
            toMergeClassification.index=[];
        end
        
        
        %if the [iInputs]th entry in inputClassifications is not empty
        %either load it (if it is a string) or set toMergeclassification to that variable
        if ~isempty(inputClassifications{iInputs})
            if or(ischar(inputClassifications{iInputs}),inputClassifications(inputFGs{iInputs}))
                toMergeClassification=load(inputClassifications{iInputs});
            elseif isstruc(ischar(inputClassifications{iInputs}))
                toMergeClassification=inputClassifications{iInputs};
            else
                warning('\n Input classification type not recognized for input %i',iInputs)
            end
            %merge it
            mergedClassification = bsc_mergeClassifications(mergedClassification,toMergeClassification);
        else
            %if the [iInputs]th entry in inputClassifications is empty,
            %just go ahead and make a single tract classification structure
            %for this fg.
            toMergeClassification.names{1}=toMergeFG.name;
            toMergeClassification.index(1:length(toMergeFG.fibers),1)=1;

            %merge it
            mergedClassification = bsc_mergeClassifications(mergedClassification,toMergeClassification);
        end
       %merging can't go outside of the above conditinials, in order to prevent weird stuff from happening 
    end
    
    

    %end of input fg loop
end
%end of function
end